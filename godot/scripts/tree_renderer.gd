## Renders the tree using smoothed ArrayMesh for wood/root and MultiMesh for
## leaves/fruit/dirt.
##
## Built once at startup (static mesh -- not updated per frame). Wood
## (trunk + branch) and root geometry is rendered as smoothed ArrayMesh
## surfaces generated by the Rust mesh_smooth module, which displaces
## vertices at diagonal neighbor boundaries to create organic ramps and
## chamfered edges instead of raw cubes. Leaf, fruit, and dirt voxels remain
## as MultiMeshInstance3D (unit BoxMesh with alpha-scissor texture for leaves,
## SphereMesh for fruit, unit BoxMesh for dirt).
##
## The smoothed mesh data comes from SimBridge as Dictionaries with
## "vertices" (PackedVector3Array), "normals" (PackedVector3Array), and
## "indices" (PackedInt32Array) keys. These are assembled into ArrayMesh
## surfaces with per-vertex normals for smooth shading.
##
## See also: mesh_smooth.rs for the smoothing algorithm, sim_bridge.rs for
## get_smoothed_wood_mesh() / get_smoothed_root_mesh() / get_leaf_voxels() /
## get_fruit_voxels() / get_dirt_voxels(), tree_gen.rs (Rust) for how the
## voxel geometry is generated via energy-based recursive segment growth,
## sim.rs for fruit spawning logic, main.gd which creates this node and
## calls setup().

extends Node3D

var _wood_mesh_instance: MeshInstance3D
var _root_mesh_instance: MeshInstance3D
var _leaf_mesh_instance: MultiMeshInstance3D
var _fruit_mesh_instance: MultiMeshInstance3D
var _dirt_mesh_instance: MultiMeshInstance3D


## Call after SimBridge is initialized to build the tree meshes.
func setup(bridge: SimBridge) -> void:
	# --- Smoothed wood (trunk + branch) ---
	var wood_data := bridge.get_smoothed_wood_mesh()
	var wood_vert_count := 0
	if wood_data.has("vertices"):
		var verts: PackedVector3Array = wood_data["vertices"]
		wood_vert_count = verts.size()
		if wood_vert_count > 0:
			_wood_mesh_instance = _create_smoothed_mesh(wood_data, Color(0.38, 0.25, 0.12))
			_wood_mesh_instance.name = "WoodMesh"
			add_child(_wood_mesh_instance)

	# --- Smoothed root ---
	var root_data := bridge.get_smoothed_root_mesh()
	var root_vert_count := 0
	if root_data.has("vertices"):
		var verts: PackedVector3Array = root_data["vertices"]
		root_vert_count = verts.size()
		if root_vert_count > 0:
			_root_mesh_instance = _create_smoothed_mesh(root_data, Color(0.30, 0.20, 0.12))
			_root_mesh_instance.name = "RootMesh"
			add_child(_root_mesh_instance)

	# --- Leaves (MultiMesh, unchanged) ---
	var leaf_voxels := bridge.get_leaf_voxels()
	var leaf_count := leaf_voxels.size() / 3
	if leaf_count > 0:
		_leaf_mesh_instance = _create_leaf_multimesh(leaf_voxels, leaf_count)
		_leaf_mesh_instance.name = "LeafMultiMesh"
		add_child(_leaf_mesh_instance)

	# --- Fruit (MultiMesh, unchanged) ---
	var fruit_voxels := bridge.get_fruit_voxels()
	var fruit_count := fruit_voxels.size() / 3
	if fruit_count > 0:
		_fruit_mesh_instance = _create_fruit_multimesh(fruit_voxels, fruit_count)
		_fruit_mesh_instance.name = "FruitMultiMesh"
		add_child(_fruit_mesh_instance)

	# --- Dirt ---
	var dirt_voxels := bridge.get_dirt_voxels()
	var dirt_count := dirt_voxels.size() / 3
	if dirt_count > 0:
		_dirt_mesh_instance = _create_voxel_multimesh(
			dirt_voxels, dirt_count, Color(0.25, 0.45, 0.2)  # Grassy green
		)
		_dirt_mesh_instance.name = "DirtMultiMesh"
		add_child(_dirt_mesh_instance)

	print(
		(
			"TreeRenderer: %d wood verts, %d root verts, %d leaf, %d fruit, %d dirt voxels"
			% [wood_vert_count, root_vert_count, leaf_count, fruit_count, dirt_count]
		)
	)


func _create_smoothed_mesh(data: Dictionary, color: Color) -> MeshInstance3D:
	var verts: PackedVector3Array = data["vertices"]
	var norms: PackedVector3Array = data["normals"]
	var idxs: PackedInt32Array = data["indices"]

	var arrays := []
	arrays.resize(Mesh.ARRAY_MAX)
	arrays[Mesh.ARRAY_VERTEX] = verts
	arrays[Mesh.ARRAY_NORMAL] = norms
	arrays[Mesh.ARRAY_INDEX] = idxs

	var arr_mesh := ArrayMesh.new()
	arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)

	var mat := StandardMaterial3D.new()
	mat.albedo_color = color
	arr_mesh.surface_set_material(0, mat)

	var instance := MeshInstance3D.new()
	instance.mesh = arr_mesh
	return instance


func _create_voxel_multimesh(
	voxels: PackedInt32Array, count: int, color: Color
) -> MultiMeshInstance3D:
	var mesh := BoxMesh.new()
	mesh.size = Vector3(1.0, 1.0, 1.0)

	var mat := StandardMaterial3D.new()
	mat.albedo_color = color
	mesh.material = mat

	var multi_mesh := MultiMesh.new()
	multi_mesh.transform_format = MultiMesh.TRANSFORM_3D
	multi_mesh.mesh = mesh
	multi_mesh.instance_count = count

	for i in count:
		var idx := i * 3
		var x := float(voxels[idx])
		var y := float(voxels[idx + 1])
		var z := float(voxels[idx + 2])
		# Offset by 0.5 so the cube center aligns with voxel position.
		var xform := Transform3D(Basis.IDENTITY, Vector3(x + 0.5, y + 0.5, z + 0.5))
		multi_mesh.set_instance_transform(i, xform)

	var instance := MultiMeshInstance3D.new()
	instance.multimesh = multi_mesh
	return instance


func _create_leaf_multimesh(voxels: PackedInt32Array, count: int) -> MultiMeshInstance3D:
	var mesh := BoxMesh.new()
	mesh.size = Vector3(1.0, 1.0, 1.0)

	var mat := StandardMaterial3D.new()
	mat.albedo_color = Color(1.0, 1.0, 1.0, 1.0)
	mat.albedo_texture = _generate_leaf_texture()
	mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA_SCISSOR
	mat.alpha_scissor_threshold = 0.5
	mat.cull_mode = BaseMaterial3D.CULL_DISABLED  # Visible from inside too
	mat.texture_filter = BaseMaterial3D.TEXTURE_FILTER_NEAREST

	mesh.material = mat

	var multi_mesh := MultiMesh.new()
	multi_mesh.transform_format = MultiMesh.TRANSFORM_3D
	multi_mesh.mesh = mesh
	multi_mesh.instance_count = count

	for i in count:
		var idx := i * 3
		var x := float(voxels[idx])
		var y := float(voxels[idx + 1])
		var z := float(voxels[idx + 2])
		var xform := Transform3D(Basis.IDENTITY, Vector3(x + 0.5, y + 0.5, z + 0.5))
		multi_mesh.set_instance_transform(i, xform)

	var instance := MultiMeshInstance3D.new()
	instance.multimesh = multi_mesh
	return instance


func _create_fruit_multimesh(voxels: PackedInt32Array, count: int) -> MultiMeshInstance3D:
	var mesh := SphereMesh.new()
	mesh.radius = 0.4
	mesh.height = 0.8
	mesh.radial_segments = 8
	mesh.rings = 4

	var mat := StandardMaterial3D.new()
	mat.albedo_color = Color(0.95, 0.65, 0.15)  # Warm amber/gold
	mat.emission_enabled = true
	mat.emission = Color(0.6, 0.35, 0.05)  # Subtle warm glow
	mat.emission_energy_multiplier = 0.3
	mesh.material = mat

	var multi_mesh := MultiMesh.new()
	multi_mesh.transform_format = MultiMesh.TRANSFORM_3D
	multi_mesh.mesh = mesh
	multi_mesh.instance_count = count

	for i in count:
		var idx := i * 3
		var x := float(voxels[idx])
		var y := float(voxels[idx + 1])
		var z := float(voxels[idx + 2])
		var xform := Transform3D(Basis.IDENTITY, Vector3(x + 0.5, y + 0.5, z + 0.5))
		multi_mesh.set_instance_transform(i, xform)

	var instance := MultiMeshInstance3D.new()
	instance.multimesh = multi_mesh
	return instance


## Generate a Minecraft-style leaf texture: 16x16 with opaque green patches
## and fully transparent holes, giving an organic canopy look.
func _generate_leaf_texture() -> ImageTexture:
	var size := 16
	var img := Image.create(size, size, false, Image.FORMAT_RGBA8)
	img.fill(Color(0.0, 0.0, 0.0, 0.0))  # Start fully transparent

	# Several green shades for variation.
	var greens := [
		Color(0.18, 0.55, 0.15, 1.0),  # Base green
		Color(0.15, 0.48, 0.12, 1.0),  # Dark green
		Color(0.22, 0.62, 0.18, 1.0),  # Light green
		Color(0.20, 0.50, 0.14, 1.0),  # Mid green
	]

	# Fill ~60% of pixels with green, leaving ~40% transparent (holes).
	# Use a deterministic pattern based on pixel position.
	for y in range(size):
		for x in range(size):
			# Simple hash for deterministic pseudo-random pattern.
			var h := (x * 7 + y * 13 + x * y * 3) % 17
			if h < 10:  # ~60% fill rate
				var shade_idx := (x * 3 + y * 5) % greens.size()
				img.set_pixel(x, y, greens[shade_idx])

	return ImageTexture.create_from_image(img)
